# 서론
* RSA 암호 알고리즘은 공개키 암호시스템의 하나
* 1978년 MIT의 대학원생 Ronald L. Rivest와 Adi Shamir, 그들의 지도 교수인 Leonard Adleman의 연구로 체계화된 알고리즘
* RSA은 그들의 첫 글자를 이어 붙인 것
* RSA 암호 알고리즘의 안전성은 아주 큰 두 소수의 곱으로 이루어진 합성수를 인수분해하기 어렵다는 인수분해 문제의 어려움에 기반
* 따라서 RSA로 암호화할 때는 합성수의 소인수분해가 어려워지도록 각 인자를 적절히 설정해야함
* RSA는 암복호화 과정에서 AES를 비롯한 대칭키 암호 알고리즘보다 훨씬 많은 연산을 필요
* 그래서, 많은 데이터를 여러 번 암호화해야하는 네트워크 통신에서는 잘 사용하지 않음

# RSA 암호 알고리즘
* 대치킹 암호화 달리 두 개의 키가 사용됨
* 공개키(Public Key)로 모든 사용자가에게 공겨되며, 평문을 암호화할 때 사용
* 개인키(Private Key)로 타인에게 노출되어서는 안되며, 공개키로 암호화된 암호문을 복호화할 때 사용

## 오일러 정리
* n과 서로소인 양의 정수 m이 다음 식을 만족한다는 정리 -> mφ(n) ≡ 1 (mod n)
* 여기서 φ(n)는 오일러 파이 함수(Euler's phi fucntion)이라고 불리며, n 이하의 양의 정수 중에서 n과 서로소인 수의 개수를 뜻함
* 예를 들어 6 이하의 양의 정수 중에서 6과 서로소인 수는 1, 5로 두 개이기 때문에 φ(6) = 2이고, 소수 p의 경우에는 1부터 p-1까지 모두 p와 서로소이기 때문에 φ(p) = p -1가 됨

## 키 생성
* 공개키 암호 알고리즘에서는 공개키와 개인키를 생성하는 키 생성 과정이 필요
* 대칭키 암호 알고리즘에서는 임의의 난수를 선택하기만 하면 되지만, RSA는 인수분해를 어렵게 하기 위해 복잡한 연산을 거쳐 키를 생성해야함

1. 먼저 서로 다른 두 소수 p와 q를 선택. 일반적으로 1024비트 이상에서 비트 길이가 같은 수로 생성
2. p와 q를 곱하여 n을 구하고 φ(n)을 계산. n = p * q 인데, p와 q가 소수이므로, φ(n)은 n보다 작으면 p와 q의 배수가 아닌 수들의 개수가 됨
3. 다시 식을 정리하면 φ(n) = p * q - p - q + 1 = (p - 1)(q - 1)
4. φ(n)을 구한 뒤, φ(n)보다 작은 수 중 φ(n)과 서로소인 e를 선택하고, d ≡ e^-1 mod φ(n)인 d를 구함
5. e < φ(n), gcd(e, φ(n)) = 1
6. d ≡ e^1(mod φ(n))

* 위 과정으로 생성한 값들 중, n과 e는 공개키로 d는 개인키로 사용
* n은 mudulus, e는 공개 지수(public exponent), d는 비밀 지수(private exponent) 라고 불림

## 암호화
* 공개키 (n, e)로 n보다 작은 평문 m을 암호화할 때, 암호문 c는 다음 식으로 구해짐 -> c ≡ m^e (mod n)

## 복호화
* 암호문 c를 개인키 d로 복호할 때, 평문 m은 다음과 같이 구해질 수 있음
    * m ≡ c^d (mod n)
    * c^d ≡ (m^e)^d ≡ m^ed (mod n)
    * m^ed ≡ (m^φ(n))^k * m (mod n)
    * (m^φ(n))m ≡ m (mod n)

---

# RSA 공격

## 작은 e
* RSA 암호 알고리즘을 구현할 때, 빠른 암호화를 위해 공개 지수 e를 작게 설정하기도 함.
* 하지만 너무 e를 작게 설정하면 Coppersmith 공격과 Hastad's Broadcast 공격 등에 취약해질 수 있음

### Coppersmith 공격
* Coppersmith 정리에 따르면, 차수가 e인 함수 f(x)에서 찾고자 하는 근이 n^(1/e)보다 작은 경우, 복잡도가 O(log n)인 알고리즘을 이용하여 근을 구할 수 있음
* 이를 RSA에 적용할 경우 평문을 얻어낼 수 있음.
* 예를 들어 e = 3이고 평문의 비트 중 상위 2/3 이상을 알고 있고 이를 a라고 한다면 f(x) = (a + x)^3을 만들어 Coppersmith 정리를 사용해 전체 평문을 얻어낼 수 있음

### Hastad's Broadcast
* 한 송신자가 다수의 수신자에게 동일한 평문을 전송할 때, 수신자들에게 모두 동일한 작은 e 값을 사용할 경우 가능한 공격 방법
* 공개키 e = 3을 가진 3명의 수신자들에게 같은 평문 m을 암호화해서 보내는 경우에 중국인의 나머지 정리를 이용하면
* m^3 ≡ c (mod n1\*n2\*n3)
* m^3 < n1\*n2\*n3이 성립 따라서 m^3 = c 라는 등식을 얻을 수 있음

> 공개 지수가 작으면 이 두개의 공격 외에도 Coppersmith의 짧은 패드 공격등에 취약함.
> 그렇다고 공개 지수를 너무 큰 값으로 설정하면 효율이 떨어짐. 따라서 일반적으로
> 공개 지수를 2^16 + 1 = 65537을 사용

---

## 공통 n 사용
### Common Modulus Attack
* 같은 n과 서로소인 두 공개 지수 e1, e2를 사용하여 같은 평문 m을 암호화해서 두 암호문 c1, c2을 만들었을 때, 이를 공격하는 기법
* 공격자는 두 공개 지수가 서로소라는 점을 활용해 r\*e1 + s\*e2 = 1 이고, r이 음수인 (r ,s) 쌍을 확장 유클리드 알고리즘을 사용해 c1^1 (mod n)을 구한다
* 수식을 어떻게 어떻게 해서 m^(r\*e1 + s\*e2) = m

## 작은 d
* 비밀 지수 d가 작아도 여러 공격에 취약. d < 1/3 * n^0.25일 경우 Wiener's attack을 이용해 d를 복구해낼 수 있으며,
* Boneh Durfee attack를 사용하면 이보다 더 넓은 범위인 d < n^0.292 일 경우에 d를 복구해낼 수 있음
* 따라서 비밀 지수를 설정할 때는 n보다 적당히 큰 수가 되도록 해줘야함