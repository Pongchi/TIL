# 서론
* DES나 AES와 같은 블록 암호는 한 번에 한 블록의 평문을 암호화하기 위해 설계됨
* DES는 64비트, AES는 128비트의 평문을 한 블록으로 처리
* UTF-8로 인코딩할 때, 알파벳 한 글자는 8비트에 대응되므로 DES와 AES는 각각 8글자, 16글자를 한번에 암호화할 수 있음
* 하지만 일반적으로 사용되는 평문의 길이는 이 길이들을 넘음. 
* 이때, 운영 모드(Mode of Operation)는 블록 암호로 이러한 다양한 크기의 데이터를 처리할 수 있도록 고안된 블록 암호의 사용 방법
* 운영 모드에는 여러 종류가 있으며, 블록 암호를 사용하는 서비스는 각각의 장단점을 고려하여 운영 모드를 선택
* 평문을 블록 단위로 만드는데 사용하는 패딩(Padding)
* 블록 암호의 대표적인 운영모드에는 ECB, CBC, CTR이 있음

# 패딩
* 블록 암호는 블록 단위로 암호화를 하므로 입력의 길이가 정확하게 블록 크기의 배수가 되어야함
* 이러한 문제를 해결하기 위해 블록 크기의 배수가 되도록 만드는 과정을 패딩(padding)이라고 함
* 널리 사용되는 패딩 기법에는 비트 패딩, 바이트 패딩, 그리고 PKCS#7 패딩이 있음

## 비트 패딩
* 마지막 블록에서 평문이 채우지 못하는 비트 중 최상위 비트를 1로 설정하고, 나머지는 모두 0으로 채우는 패딩 기법
* 수신자는 평문의 마지막 비트부터 처음으로 값이 1인 비트가 나올 때까지를 패딩으로 인식할 수 있음. 즉, 이를 제거하여 평문을 구할 수 있음
* 하지만 평문의 크기가 정확히 블록 크기의 배수일 때, 수신자가 메시지의 일부를 패딩으로 오인하게 되는 문제가있음
* 이를 방지하기 위해 비트 패딩을 적용할 때는 평문의 크기가 블록 크기의 배수이며, 패딩으로 한 블록을 추가함

## 바이트 패딩: ANSI X.923
* 바이트 단위로 패딩을 수행하는 패딩 기법
* 바이트 패딩에는 여러 종류가 있음
* 그 중 ANSI X.923은 마지막 블록의 남는 바이트의 임의의 값(일반적으로 0)으로 채우고, 마지막 바이트에 패딩의 길이를 기록하는 기법

### 예시
* 마지막 바이트의 값이 4이므로 마지막 네 바이트(00 00 00 04)가 패딩이 됨
> AA BB CC DD EE FF 00 00 | 14 50 00 00 **00 00 00 04** |

* 마찬가지로, 평문의 크기가 블록 크기의 배수일 때 수신자가 평문을 패딩으로 오인할 수 있음. 따라서 평문의 크기가 블록 크기의 배수일 때는 마지막에 한 블록을 패딩으로 추가

## 바이트 패딩: PKCS#7
* PKCS(Public-Key Cryptography Standard)는 공개키 암호의 표준 문서로서, 그중 7번째 문서인 PKCS#7은 AES와 같은 블록 암호의 패딩 기법을 제시
* PKCS#7에 소개된 패딩 기법은 추가할 패딩의 바이트 크기로 마지막 블록을 채우는 기법

### 예시
* 마지막 블록에 4바이트를 패딩
> AA BB CC DD EE FF 00 00 | 14 50 00 00 04 04 04 04 |

* 다른 패딩 기법들과 마찬가지로 평문의 크기가 블록 크기의 배수이면, PKCS#7은 | 08 08 08 08 08 08 08 08 | 을 패딩으로 추가

---

# 운영 모드

## ECB 모드
* 블록 암호로 평문을 암호화할 때 평문은 패딩을 거친 뒤 여러 블록으로 나뉨
* 그리고 각각의 블록은 운영 모드에 따라 암호화됨
* ECB(Electronic Code Book) 모드는 가장 간단한 운영모드로, 블록들은 모두 같은 키로 암호화됨
* ECB 모드에서는 각 블록이 독립적으로 암호화되므로 여러 블록을 병렬적으로 암화할 수 있다는 장점이 있음
* 하지만, 다른 운영모드에 비해 암호학적 안전성이 부족하다는 단점이 있음

### 약한 혼돈 성질
* 이미지의 한 픽셀을 한 블록으로 하여 ECB 암호화하면 같은 픽셀들은 모두 같은 픽셀로 암호화되므로, 원본 이미지의 패턴이 암호화된 이미지에도 그대로 나타남
* 이는 암호문으로부터 평문의 정보를 유추하기 어려워야 한다는 혼돈 성질이 약함을 의미

[ Tux 원본 ]
https://kr.object.ncloudstorage.com/dreamhack-content/page/b77ab2b6705cb006932f5c59428b0e08b9e5a858a25ad464ccce1172d6507d0a.jpg

[ ECB로 암호화한 Tux ]
https://kr.object.ncloudstorage.com/dreamhack-content/page/730bd3e6a187fac7a06af1023fe02c04257ab87ad9c35254c9563f1d74c7d429.jpg

### 재전송 공격
* 어떤 데이터를 재전송하여 시스템이 의도치 않은 행동을 하게 하는 공격
* ECB 모드는 다음과 같은 방식으로 재전송 공격을 당할 수 있음
* 만약, Alice가 'Alice sent 10000$ to Bob'이라는 24바이트 평문을 4바이트 블록 암호로 암호화하여 'a1ijc1ox0fdz0d1vforca3je'을 은행에 전송하고, 이를 해석해서 10000$를 Bob의 계좌로 송금한다고 할 때,
* 만약 Bob이 Alice가 암호화한 평문과 은행에 전송된 암호문을 알게 되면, Bob은 암호문에서 '0000'을 암호한 결과가 '0d1v' 라는 사실을 알 수 있음
* Bob은 이 정보를 이용하여 'a1ijc1ox0fdz0d1v0d1vforca3je'라는 암호문을 생성하고, 은행에 전송할 수 있음.
* 이 암호문을 복호화하면 'Alice sent 100000000$ to Bob' 이므로, 은행은 Alice의 계좌에서 100000000$를 인출하여 Bob에게 송금하게됨

---

## CBC 모드
* CBC(Cipher Block Chaining) 모드는 어떤 블록을 암호화하기 전에, 이 블록을 직전 블록의 암호문과 XOR함
* 평문의 첫 번째 블록은 이전 블록이 존재하지 않으므로, 초기 벡터(Initialization Vector Vector, IV)라고 불리는 임의의 데이터와 XOR함
* 이 모드를 사용하면 각 브록이 서로의 암호화에 영향을 주므로 같은 블록도 전체 평문 및 IV에 따라 암호화 결과가 달라짐
* 송신자는 초기 벡터를 암호문의 0번째 블록 C0에 전송
* 초기 벡터는 일반적으로 논스(Nonce, number used only once)라는 무작위 값은 사용
* 이는 공격자가 알아도 안정성에 영향을 끼치지 않음
* 하지만 만약, 공격자가 암호문을 중간에 가로채서 이를 조작할 수 있으면, 복호화 결과의 첫 번째 블록을 조작할 수 있음
* 즉, CBC 모드를 사용할 때는 초기 벡터의 무결성을 함께 보장해야 함
* CBC모드는 재전송 공격에 강인하며, 높은 혼동성을 가지고 있어서 블록 암호의 운영 모드로 널리 사용되고 있음

### CBC Bit-Flipping Attack
* 공격자가 초기 벡터를 원하는 값으로 조작하여 복화화된 평문의 첫 번째 블록을 조작하는 공격

---

## CTR 모드
* CTR(Counter) 모드는 블록 암호에 nonce와 평문 블록을 인덱스(counter)를 결합한 값을 입력.
* 암호문은 블록 암호의 출력과 평문 블록을 XOR하여 생성
* CTR 모드는 블록을 순서대로 암복호화하지 않아도 되므로 병렬로 암복호화할 수 있으며, 구현이 간단함

---
# 마치며
* 이 외에도 CFB, OFB, 그리고 현재 네트워크에서 많이 사용되고 있는 GCM 등 다양한 모드가 있음